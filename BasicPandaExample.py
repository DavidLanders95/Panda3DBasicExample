#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Mon Oct 26 00:52:19 2020

@author: david
"""

from math import pi, sin, cos

from direct.showbase.ShowBase import ShowBase
from direct.task import Task
from direct.actor.Actor import Actor
from panda3d.core import CollisionTraverser, CollisionHandlerPusher, CollisionSphere, CollisionTube, CollisionNode
from panda3d.core import AmbientLight, DirectionalLight
from panda3d.core import Vec4, Vec3
from panda3d.core import WindowProperties
from panda3d.core import *
from panda3d.bullet import BulletCylinderShape
from FirstPersonCamera import FirstPersonCamera

# You can't normalize inline so this is a helper function
def normalized(*args):
    myVec = LVector3(*args)
    myVec.normalize()
    return myVec


class Game(ShowBase):
    
    def __init__(self):
        ShowBase.__init__(self)

        
        #renaming properties
        properties = WindowProperties()
        
        #set windows size property
        properties.setSize(1000, 750)
        
        #activate the property to the current window
        self.win.requestProperties(properties)

        #Calling one of Panda's lighting functions and naming it
        ambientLight = AmbientLight("ambient light")
        
        #setting the colour
        ambientLight.setColor(Vec4(1, 1, 1, 1))
        
        #creating a lighting node and adding it to the render list (doesn't do anything yet)
        self.ambientLightNodePath = self.render.attachNewNode(ambientLight)
        
        #We need to also use the setLight function to actually light the scene
        self.render.setLight(self.ambientLightNodePath)
        
        #choose shader
        self.render.setShaderAuto()
        
        #gather main camera generated by showbase
        self.first_person_camera_node = self.cam
        self.mouseLook = FirstPersonCamera(self, self.first_person_camera_node, self.render)  
        
        lens = OrthographicLens()
        lens.setFilmSize(2, 2)  # Or whatever is appropriate for your scene

        self.spot_camera = Camera("Spot Camera")
        self.spot_camera.setLens(lens)
        self.spot_camera_node = self.render.attachNewNode(self.spot_camera)
        self.spot_camera_node.node().setLens(lens)
        self.spot_camera_node.setName("Spot Camera")
        self.spot_camera_node.setPos(2, 0, 0)
        self.spot_camera_node.lookAt(0, 0, 0)
        
        dr = base.camNode.getDisplayRegion(0)
        dr.setActive(0)
        
        window = dr.getWindow()
        dr1 = window.makeDisplayRegion(0, 0.8, 0, 1)
        dr1.setSort(dr.getSort())
        
        dr2 = window.makeDisplayRegion(0.8, 0.9, 0.2, 0.4)
        dr2.setSort(dr.getSort())
        
        dr1.setCamera(self.first_person_camera_node)
        dr2.setCamera(self.spot_camera_node)
      
        axes = self.createAxes(2)
        axes.reparentTo(self.render)
        
        self.Line = self.render.attachNewNode(LineSegs().create())
        
        self.taskMgr.add(self.update, "Update")
    
    def update(self, task): 
        
        dt = task.time
        x = cos(dt)
        y = sin(dt)
        
        self.drawLine(start = (0.0, 0.0, 1.0), end = (x, y, 0.0))

        return Task.cont 
        
    def createAxes(self, lineThickness=1):
    
        ls = LineSegs()
        ls.setThickness(lineThickness)
        
        # X axis
        ls.setColor(1.0, 0.0, 0.0, 1.0)
        ls.moveTo(0.0, 0.0, 0.0)
        ls.drawTo(1.0, 0.0, 0.0)
        
        # Y axis
        ls.setColor(0.0, 1.0, 0.0, 1.0)
        ls.moveTo(0.0, 0.0, 0.0)
        ls.drawTo(0.0, 1.0, 0.0)
        
        # Z axis
        ls.setColor(0.0, 0.0, 1.0, 1.0)
        ls.moveTo(0.0, 0.0, 0.0)
        ls.drawTo(0.0, 0.0, 1.0)
        
        node = ls.create()
    
        return NodePath(node)
    
    def createArc(self, radius = 1, angleDegrees = 360, numSteps = 48, lineThickness = 1, z = 1):
        
        ls = LineSegs()
        ls.setThickness(lineThickness)
        
        angleRadians = deg2Rad(angleDegrees)
        
        for i in range(numSteps + 1):
            a = angleRadians * i / numSteps
            y = radius * sin(a)
            x = radius * cos(a)
        
            ls.setColor(1.0, 1.0, 1.0, 1.0)
            ls.drawTo(x, y, z)
        
        node = ls.create()
        
        return NodePath(node)
    
    def drawLine(self, start, end, lineThickness=1):
        
        self.Line.removeNode()
        
        ls = LineSegs()
        ls.setThickness(lineThickness)
        
        ls.setColor(1.0, 1.0, 1.0, 1.0)
        ls.moveTo(start)
        ls.drawTo(end)
        
        node = ls.create()
        
        self.Line = self.render.attachNewNode(node)
    
        return NodePath(node)
    
game = Game()
game.run()